<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_65) on Thu Jan 22 17:15:23 PST 2015 -->
<title>PredictionMode</title>
<meta name="date" content="2015-01-22">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PredictionMode";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/antlr/v4/runtime/atn/PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/antlr/v4/runtime/atn/ProfilingATNSimulator.html" title="class in org.antlr.v4.runtime.atn"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/antlr/v4/runtime/atn/PredictionMode.html" target="_top">Frames</a></li>
<li><a href="PredictionMode.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum_constant_summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum_constant_detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.antlr.v4.runtime.atn</div>
<h2 title="Enum PredictionMode" class="title">Enum PredictionMode</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>java.lang.Enum&lt;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&gt;</li>
<li>
<ul class="inheritance">
<li>org.antlr.v4.runtime.atn.PredictionMode</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable, java.lang.Comparable&lt;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&gt;</dd>
</dl>
<hr>
<br>
<pre>public enum <span class="strong">PredictionMode</span>
extends java.lang.Enum&lt;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&gt;</pre>
<div class="block">This enumeration defines the prediction modes available in ANTLR 4 along with
 utility methods for analyzing configuration sets for conflicts and/or
 ambiguities.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ENUM CONSTANT SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="enum_constant_summary">
<!--   -->
</a>
<h3>Enum Constant Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Enum Constant Summary table, listing enum constants, and an explanation">
<caption><span>Enum Constants</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Enum Constant and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#LL">LL</a></strong></code>
<div class="block">The LL(*) prediction mode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#LL_EXACT_AMBIG_DETECTION">LL_EXACT_AMBIG_DETECTION</a></strong></code>
<div class="block">The LL(*) prediction mode with exact ambiguity detection.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#SLL">SLL</a></strong></code>
<div class="block">The SLL(*) prediction mode.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#allConfigsInRuleStopStates(org.antlr.v4.runtime.atn.ATNConfigSet)">allConfigsInRuleStopStates</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>
<div class="block">Checks if all configurations in <code>configs</code> are in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#allSubsetsConflict(java.util.Collection)">allSubsetsConflict</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Determines if every alternative subset in <code>altsets</code> contains more
 than one alternative.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#allSubsetsEqual(java.util.Collection)">allSubsetsEqual</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Determines if every alternative subset in <code>altsets</code> is equivalent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.BitSet</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#getAlts(java.util.Collection)">getAlts</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Gets the complete set of represented alternatives for a collection of
 alternative subsets.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Collection&lt;java.util.BitSet&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#getConflictingAltSubsets(org.antlr.v4.runtime.atn.ATNConfigSet)">getConflictingAltSubsets</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>
<div class="block">This function gets the conflicting alt subsets from a configuration set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#getSingleViableAlt(java.util.Collection)">getSingleViableAlt</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Map&lt;<a href="../../../../../org/antlr/v4/runtime/atn/ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a>,java.util.BitSet&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#getStateToAltMap(org.antlr.v4.runtime.atn.ATNConfigSet)">getStateToAltMap</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>
<div class="block">Get a map from state to alt subset from a configuration set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#getUniqueAlt(java.util.Collection)">getUniqueAlt</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Returns the unique alternative predicted by all alternative subsets in
 <code>altsets</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#hasConfigInRuleStopState(org.antlr.v4.runtime.atn.ATNConfigSet)">hasConfigInRuleStopState</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>
<div class="block">Checks if any configuration in <code>configs</code> is in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#hasConflictingAltSet(java.util.Collection)">hasConflictingAltSet</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Determines if any single alternative subset in <code>altsets</code> contains
 more than one alternative.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#hasNonConflictingAltSet(java.util.Collection)">hasNonConflictingAltSet</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Determines if any single alternative subset in <code>altsets</code> contains
 exactly one alternative.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#hasSLLConflictTerminatingPrediction(org.antlr.v4.runtime.atn.PredictionMode,%20org.antlr.v4.runtime.atn.ATNConfigSet)">hasSLLConflictTerminatingPrediction</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;mode,
                                   <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>
<div class="block">Computes the SLL prediction termination condition.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#hasStateAssociatedWithOneAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">hasStateAssociatedWithOneAlt</a></strong>(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#resolvesToJustOneViableAlt(java.util.Collection)">resolvesToJustOneViableAlt</a></strong>(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</code>
<div class="block">Full LL prediction termination.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a></code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#valueOf(java.lang.String)">valueOf</a></strong>(java.lang.String&nbsp;name)</code>
<div class="block">Returns the enum constant of this type with the specified name.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>[]</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#values()">values</a></strong>()</code>
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Enum">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Enum</h3>
<code>clone, compareTo, equals, finalize, getDeclaringClass, hashCode, name, ordinal, toString, valueOf</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ENUM CONSTANT DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="enum_constant_detail">
<!--   -->
</a>
<h3>Enum Constant Detail</h3>
<a name="SLL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SLL</h4>
<pre>public static final&nbsp;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a> SLL</pre>
<div class="block">The SLL(*) prediction mode. This prediction mode ignores the current
 parser context when making predictions. This is the fastest prediction
 mode, and provides correct results for many grammars. This prediction
 mode is more powerful than the prediction mode provided by ANTLR 3, but
 may result in syntax errors for grammar and input combinations which are
 not SLL.

 <p>
 When using this prediction mode, the parser will either return a correct
 parse tree (i.e. the same parse tree that would be returned with the
 <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#LL"><code>LL</code></a> prediction mode), or it will report a syntax error. If a
 syntax error is encountered when using the <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#SLL"><code>SLL</code></a> prediction mode,
 it may be due to either an actual syntax error in the input or indicate
 that the particular combination of grammar and input requires the more
 powerful <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#LL"><code>LL</code></a> prediction abilities to complete successfully.</p>

 <p>
 This prediction mode does not provide any guarantees for prediction
 behavior for syntactically-incorrect inputs.</p></div>
</li>
</ul>
<a name="LL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LL</h4>
<pre>public static final&nbsp;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a> LL</pre>
<div class="block">The LL(*) prediction mode. This prediction mode allows the current parser
 context to be used for resolving SLL conflicts that occur during
 prediction. This is the fastest prediction mode that guarantees correct
 parse results for all combinations of grammars with syntactically correct
 inputs.

 <p>
 When using this prediction mode, the parser will make correct decisions
 for all syntactically-correct grammar and input combinations. However, in
 cases where the grammar is truly ambiguous this prediction mode might not
 report a precise answer for <em>exactly which</em> alternatives are
 ambiguous.</p>

 <p>
 This prediction mode does not provide any guarantees for prediction
 behavior for syntactically-incorrect inputs.</p></div>
</li>
</ul>
<a name="LL_EXACT_AMBIG_DETECTION">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>LL_EXACT_AMBIG_DETECTION</h4>
<pre>public static final&nbsp;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a> LL_EXACT_AMBIG_DETECTION</pre>
<div class="block">The LL(*) prediction mode with exact ambiguity detection. In addition to
 the correctness guarantees provided by the <a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html#LL"><code>LL</code></a> prediction mode,
 this prediction mode instructs the prediction algorithm to determine the
 complete and exact set of ambiguous alternatives for every ambiguous
 decision encountered while parsing.

 <p>
 This prediction mode may be used for diagnosing ambiguities during
 grammar development. Due to the performance overhead of calculating sets
 of ambiguous alternatives, this prediction mode should be avoided when
 the exact results are not necessary.</p>

 <p>
 This prediction mode does not provide any guarantees for prediction
 behavior for syntactically-incorrect inputs.</p></div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="values()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>values</h4>
<pre>public static&nbsp;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>[]&nbsp;values()</pre>
<div class="block">Returns an array containing the constants of this enum type, in
the order they are declared.  This method may be used to iterate
over the constants as follows:
<pre>
for (PredictionMode c : PredictionMode.values())
&nbsp;   System.out.println(c);
</pre></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an array containing the constants of this enum type, in the order they are declared</dd></dl>
</li>
</ul>
<a name="valueOf(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>valueOf</h4>
<pre>public static&nbsp;<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;valueOf(java.lang.String&nbsp;name)</pre>
<div class="block">Returns the enum constant of this type with the specified name.
The string must match <i>exactly</i> an identifier used to declare an
enum constant in this type.  (Extraneous whitespace characters are 
not permitted.)</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>name</code> - the name of the enum constant to be returned.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the enum constant with the specified name</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if this enum type has no constant with the specified name</dd>
<dd><code>java.lang.NullPointerException</code> - if the argument is null</dd></dl>
</li>
</ul>
<a name="hasSLLConflictTerminatingPrediction(org.antlr.v4.runtime.atn.PredictionMode, org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSLLConflictTerminatingPrediction</h4>
<pre>public static&nbsp;boolean&nbsp;hasSLLConflictTerminatingPrediction(<a href="../../../../../org/antlr/v4/runtime/atn/PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;mode,
                                          <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Computes the SLL prediction termination condition.

 <p>
 This method computes the SLL prediction termination condition for both of
 the following cases.</p>

 <ul>
 <li>The usual SLL+LL fallback upon SLL conflict</li>
 <li>Pure SLL without LL fallback</li>
 </ul>

 <p><strong>COMBINED SLL+LL PARSING</strong></p>

 <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
 ensured regardless of how the termination condition is computed by this
 method. Due to the substantially higher cost of LL prediction, the
 prediction should only fall back to LL when the additional lookahead
 cannot lead to a unique SLL prediction.</p>

 <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
 conflicting subsets should fall back to full LL, even if the
 configuration sets don't resolve to the same alternative (e.g.
 <code>{1,2}</code> and <code>{3,4}</code>. If there is at least one non-conflicting
 configuration, SLL could continue with the hopes that more lookahead will
 resolve via one of those non-conflicting configurations.</p>

 <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
 stops when it sees only conflicting configuration subsets. In contrast,
 full LL keeps going when there is uncertainty.</p>

 <p><strong>HEURISTIC</strong></p>

 <p>As a heuristic, we stop prediction when we see any conflicting subset
 unless we see a state that only has one alternative associated with it.
 The single-alt-state thing lets prediction continue upon rules like
 (otherwise, it would admit defeat too soon):</p>

 <p><code>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</code></p>

 <p>When the ATN simulation reaches the state before <code>';'</code>, it has a
 DFA state that looks like: <code>[12|1|[], 6|2|[], 12|2|[]]</code>. Naturally
 <code>12|1|[]</code> and <code>12|2|[]</code> conflict, but we cannot stop
 processing this node because alternative to has another way to continue,
 via <code>[6|2|[]]</code>.</p>

 <p>It also let's us continue for this rule:</p>

 <p><code>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</code></p>

 <p>After matching input A, we reach the stop state for rule A, state 1.
 State 8 is the state right before B. Clearly alternatives 1 and 2
 conflict and no amount of further lookahead will separate the two.
 However, alternative 3 will be able to continue and so we do not stop
 working on this state. In the previous example, we're concerned with
 states associated with the conflicting alternatives. Here alt 3 is not
 associated with the conflicting configs, but since we can continue
 looking for input reasonably, don't declare the state done.</p>

 <p><strong>PURE SLL PARSING</strong></p>

 <p>To handle pure SLL parsing, all we have to do is make sure that we
 combine stack contexts for configurations that differ only by semantic
 predicate. From there, we can do the usual SLL termination heuristic.</p>

 <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>

 <p>SLL decisions don't evaluate predicates until after they reach DFA stop
 states because they need to create the DFA cache that works in all
 semantic situations. In contrast, full LL evaluates predicates collected
 during start state computation so it can ignore predicates thereafter.
 This means that SLL termination detection can totally ignore semantic
 predicates.</p>

 <p>Implementation-wise, <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn"><code>ATNConfigSet</code></a> combines stack contexts but not
 semantic predicate contexts so we might see two configurations like the
 following.</p>

 <p><code>(s, 1, x, {}), (s, 1, x', {p})</code></p>

 <p>Before testing these configurations against others, we have to merge
 <code>x</code> and <code>x'</code> (without modifying the existing configurations).
 For example, we test <code>(x+x')==x''</code> when looking for conflicts in
 the following configurations.</p>

 <p><code>(s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})</code></p>

 <p>If the configuration set has predicates (as indicated by
 <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html#hasSemanticContext"><code>ATNConfigSet.hasSemanticContext</code></a>), this algorithm makes a copy of
 the configurations to strip out all of the predicates so that a standard
 <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn"><code>ATNConfigSet</code></a> will merge everything ignoring predicates.</p></div>
</li>
</ul>
<a name="hasConfigInRuleStopState(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasConfigInRuleStopState</h4>
<pre>public static&nbsp;boolean&nbsp;hasConfigInRuleStopState(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Checks if any configuration in <code>configs</code> is in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>. Configurations meeting this condition have reached
 the end of the decision rule (local context) or end of start rule (full
 context).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>configs</code> - the configuration set to test</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if any configuration in <code>configs</code> is in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="allConfigsInRuleStopStates(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allConfigsInRuleStopStates</h4>
<pre>public static&nbsp;boolean&nbsp;allConfigsInRuleStopStates(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Checks if all configurations in <code>configs</code> are in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>. Configurations meeting this condition have reached
 the end of the decision rule (local context) or end of start rule (full
 context).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>configs</code> - the configuration set to test</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if all configurations in <code>configs</code> are in a
 <a href="../../../../../org/antlr/v4/runtime/atn/RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="resolvesToJustOneViableAlt(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resolvesToJustOneViableAlt</h4>
<pre>public static&nbsp;int&nbsp;resolvesToJustOneViableAlt(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Full LL prediction termination.

 <p>Can we stop looking ahead during ATN simulation or is there some
 uncertainty as to which alternative we will ultimately pick, after
 consuming more input? Even if there are partial conflicts, we might know
 that everything is going to resolve to the same minimum alternative. That
 means we can stop since no more lookahead will change that fact. On the
 other hand, there might be multiple conflicts that resolve to different
 minimums. That means we need more look ahead to decide which of those
 alternatives we should predict.</p>

 <p>The basic idea is to split the set of configurations <code>C</code>, into
 conflicting subsets <code>(s, _, ctx, _)</code> and singleton subsets with
 non-conflicting configurations. Two configurations conflict if they have
 identical <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#state"><code>ATNConfig.state</code></a> and <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#context"><code>ATNConfig.context</code></a> values
 but different <a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#alt"><code>ATNConfig.alt</code></a> value, e.g. <code>(s, i, ctx, _)</code>
 and <code>(s, j, ctx, _)</code> for <code>i!=j</code>.</p>

 <p>Reduce these configuration subsets to the set of possible alternatives.
 You can compute the alternative subsets in one pass as follows:</p>

 <p><code>A_s,ctx = {i | (s, i, ctx, _)}</code> for each configuration in
 <code>C</code> holding <code>s</code> and <code>ctx</code> fixed.</p>

 <p>Or in pseudo-code, for each configuration <code>c</code> in <code>C</code>:</p>

 <pre>
 map[c] U= c.<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#alt"><code>alt</code></a> # map hash/equals uses s and x, not
 alt and not pred
 </pre>

 <p>The values in <code>map</code> are the set of <code>A_s,ctx</code> sets.</p>

 <p>If <code>|A_s,ctx|=1</code> then there is no conflict associated with
 <code>s</code> and <code>ctx</code>.</p>

 <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
 the union of these alternative subsets is a singleton, then no amount of
 more lookahead will help us. We will always pick that alternative. If,
 however, there is more than one alternative, then we are uncertain which
 alternative to predict and must continue looking for resolution. We may
 or may not discover an ambiguity in the future, even if there are no
 conflicting subsets this round.</p>

 <p>The biggest sin is to terminate early because it means we've made a
 decision but were uncertain as to the eventual outcome. We haven't used
 enough lookahead. On the other hand, announcing a conflict too late is no
 big deal; you will still have the conflict. It's just inefficient. It
 might even look until the end of file.</p>

 <p>No special consideration for semantic predicates is required because
 predicates are evaluated on-the-fly for full LL prediction, ensuring that
 no configuration contains a semantic context during the termination
 check.</p>

 <p><strong>CONFLICTING CONFIGS</strong></p>

 <p>Two configurations <code>(s, i, x)</code> and <code>(s, j, x')</code>, conflict
 when <code>i!=j</code> but <code>x=x'</code>. Because we merge all
 <code>(s, i, _)</code> configurations together, that means that there are at
 most <code>n</code> configurations associated with state <code>s</code> for
 <code>n</code> possible alternatives in the decision. The merged stacks
 complicate the comparison of configuration contexts <code>x</code> and
 <code>x'</code>. Sam checks to see if one is a subset of the other by calling
 merge and checking to see if the merged result is either <code>x</code> or
 <code>x'</code>. If the <code>x</code> associated with lowest alternative <code>i</code>
 is the superset, then <code>i</code> is the only possible prediction since the
 others resolve to <code>min(i)</code> as well. However, if <code>x</code> is
 associated with <code>j&gt;i</code> then at least one stack configuration for
 <code>j</code> is not in conflict with alternative <code>i</code>. The algorithm
 should keep going, looking for more lookahead due to the uncertainty.</p>

 <p>For simplicity, I'm doing a equality check between <code>x</code> and
 <code>x'</code> that lets the algorithm continue to consume lookahead longer
 than necessary. The reason I like the equality is of course the
 simplicity but also because that is the test you need to detect the
 alternatives that are actually in conflict.</p>

 <p><strong>CONTINUE/STOP RULE</strong></p>

 <p>Continue if union of resolved alternative sets from non-conflicting and
 conflicting alternative subsets has more than one alternative. We are
 uncertain about which alternative to predict.</p>

 <p>The complete set of alternatives, <code>[i for (_,i,_)]</code>, tells us which
 alternatives are still in the running for the amount of input we've
 consumed at this point. The conflicting sets let us to strip away
 configurations that won't lead to more states because we resolve
 conflicts to the configuration with a minimum alternate for the
 conflicting set.</p>

 <p><strong>CASES</strong></p>

 <ul>

 <li>no conflicts and more than 1 alternative in set =&gt; continue</li>

 <li> <code>(s, 1, x)</code>, <code>(s, 2, x)</code>, <code>(s, 3, z)</code>,
 <code>(s', 1, y)</code>, <code>(s', 2, y)</code> yields non-conflicting set
 <code>{3}</code> U conflicting sets <code>min({1,2})</code> U <code>min({1,2})</code> =
 <code>{1,3}</code> =&gt; continue
 </li>

 <li><code>(s, 1, x)</code>, <code>(s, 2, x)</code>, <code>(s', 1, y)</code>,
 <code>(s', 2, y)</code>, <code>(s'', 1, z)</code> yields non-conflicting set
 <code>{1}</code> U conflicting sets <code>min({1,2})</code> U <code>min({1,2})</code> =
 <code>{1}</code> =&gt; stop and predict 1</li>

 <li><code>(s, 1, x)</code>, <code>(s, 2, x)</code>, <code>(s', 1, y)</code>,
 <code>(s', 2, y)</code> yields conflicting, reduced sets <code>{1}</code> U
 <code>{1}</code> = <code>{1}</code> =&gt; stop and predict 1, can announce
 ambiguity <code>{1,2}</code></li>

 <li><code>(s, 1, x)</code>, <code>(s, 2, x)</code>, <code>(s', 2, y)</code>,
 <code>(s', 3, y)</code> yields conflicting, reduced sets <code>{1}</code> U
 <code>{2}</code> = <code>{1,2}</code> =&gt; continue</li>

 <li><code>(s, 1, x)</code>, <code>(s, 2, x)</code>, <code>(s', 3, y)</code>,
 <code>(s', 4, y)</code> yields conflicting, reduced sets <code>{1}</code> U
 <code>{3}</code> = <code>{1,3}</code> =&gt; continue</li>

 </ul>

 <p><strong>EXACT AMBIGUITY DETECTION</strong></p>

 <p>If all states report the same conflicting set of alternatives, then we
 know we have the exact ambiguity set.</p>

 <p><code>|A_<em>i</em>|&gt;1</code> and
 <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>

 <p>In other words, we continue examining lookahead until all <code>A_i</code>
 have more than one alternative and all <code>A_i</code> are the same. If
 <code>A={{1,2}, {1,3}}</code>, then regular LL prediction would terminate
 because the resolved set is <code>{1}</code>. To determine what the real
 ambiguity is, we have to know whether the ambiguity is between one and
 two or one and three so we keep going. We can only stop prediction when
 we need exact ambiguity detection when the sets look like
 <code>A={{1,2}}</code> or <code>{{1,2},{1,2}}</code>, etc...</p></div>
</li>
</ul>
<a name="allSubsetsConflict(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSubsetsConflict</h4>
<pre>public static&nbsp;boolean&nbsp;allSubsetsConflict(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Determines if every alternative subset in <code>altsets</code> contains more
 than one alternative.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if every <code>BitSet</code> in <code>altsets</code> has
 <code>cardinality</code> &gt; 1, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="hasNonConflictingAltSet(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNonConflictingAltSet</h4>
<pre>public static&nbsp;boolean&nbsp;hasNonConflictingAltSet(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Determines if any single alternative subset in <code>altsets</code> contains
 exactly one alternative.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if <code>altsets</code> contains a <code>BitSet</code> with
 <code>cardinality</code> 1, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="hasConflictingAltSet(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasConflictingAltSet</h4>
<pre>public static&nbsp;boolean&nbsp;hasConflictingAltSet(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Determines if any single alternative subset in <code>altsets</code> contains
 more than one alternative.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if <code>altsets</code> contains a <code>BitSet</code> with
 <code>cardinality</code> &gt; 1, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="allSubsetsEqual(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSubsetsEqual</h4>
<pre>public static&nbsp;boolean&nbsp;allSubsetsEqual(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Determines if every alternative subset in <code>altsets</code> is equivalent.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if every member of <code>altsets</code> is equal to the
 others, otherwise <code>false</code></dd></dl>
</li>
</ul>
<a name="getUniqueAlt(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUniqueAlt</h4>
<pre>public static&nbsp;int&nbsp;getUniqueAlt(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Returns the unique alternative predicted by all alternative subsets in
 <code>altsets</code>. If no such alternative exists, this method returns
 <a href="../../../../../org/antlr/v4/runtime/atn/ATN.html#INVALID_ALT_NUMBER"><code>ATN.INVALID_ALT_NUMBER</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd></dl>
</li>
</ul>
<a name="getAlts(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAlts</h4>
<pre>public static&nbsp;java.util.BitSet&nbsp;getAlts(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
<div class="block">Gets the complete set of represented alternatives for a collection of
 alternative subsets. This method returns the union of each <code>BitSet</code>
 in <code>altsets</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>altsets</code> - a collection of alternative subsets</dd>
<dt><span class="strong">Returns:</span></dt><dd>the set of represented alternatives in <code>altsets</code></dd></dl>
</li>
</ul>
<a name="getConflictingAltSubsets(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConflictingAltSubsets</h4>
<pre>public static&nbsp;java.util.Collection&lt;java.util.BitSet&gt;&nbsp;getConflictingAltSubsets(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">This function gets the conflicting alt subsets from a configuration set.
 For each configuration <code>c</code> in <code>configs</code>:

 <pre>
 map[c] U= c.<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#alt"><code>alt</code></a> # map hash/equals uses s and x, not
 alt and not pred
 </pre></div>
</li>
</ul>
<a name="getStateToAltMap(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStateToAltMap</h4>
<pre>public static&nbsp;java.util.Map&lt;<a href="../../../../../org/antlr/v4/runtime/atn/ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a>,java.util.BitSet&gt;&nbsp;getStateToAltMap(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Get a map from state to alt subset from a configuration set. For each
 configuration <code>c</code> in <code>configs</code>:

 <pre>
 map[c.<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#state"><code>state</code></a>] U= c.<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfig.html#alt"><code>alt</code></a>
 </pre></div>
</li>
</ul>
<a name="hasStateAssociatedWithOneAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasStateAssociatedWithOneAlt</h4>
<pre>public static&nbsp;boolean&nbsp;hasStateAssociatedWithOneAlt(<a href="../../../../../org/antlr/v4/runtime/atn/ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
</li>
</ul>
<a name="getSingleViableAlt(java.util.Collection)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getSingleViableAlt</h4>
<pre>public static&nbsp;int&nbsp;getSingleViableAlt(java.util.Collection&lt;java.util.BitSet&gt;&nbsp;altsets)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/antlr/v4/runtime/atn/PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/antlr/v4/runtime/atn/ProfilingATNSimulator.html" title="class in org.antlr.v4.runtime.atn"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/antlr/v4/runtime/atn/PredictionMode.html" target="_top">Frames</a></li>
<li><a href="PredictionMode.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#enum_constant_summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#enum_constant_detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
