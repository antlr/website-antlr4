<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.17) on Mon Sep 04 15:12:06 PDT 2023 -->
<title>ParserATNSimulator (ANTLR 4 Runtime 4.13.1 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2023-09-04">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="ParserATNSimulator (ANTLR 4 Runtime 4.13.1 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":9,"i31":10,"i32":10,"i33":9,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/ParserATNSimulator.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.antlr.v4.runtime.atn</a></div>
<h2 title="Class ParserATNSimulator" class="title">Class ParserATNSimulator</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">org.antlr.v4.runtime.atn.ATNSimulator</a></li>
<li>
<ul class="inheritance">
<li>org.antlr.v4.runtime.atn.ParserATNSimulator</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="ProfilingATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ProfilingATNSimulator</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">ParserATNSimulator</span>
extends <a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ATNSimulator</a></pre>
<div class="block">The embodiment of the adaptive LL(*), ALL(*), parsing strategy.

 <p>
 The basic complexity of the adaptive strategy makes it harder to understand.
 We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 requests go through the DFA first. If they reach a state without an edge for
 the current symbol, the algorithm fails over to the ATN simulation to
 complete the DFA path for the current input (until it finds a conflict state
 or uniquely predicting state).</p>

 <p>
 All of that is done without using the outer context because we want to create
 a DFA that is not dependent upon the rule invocation stack when we do a
 prediction. One DFA works in all contexts. We avoid using context not
 necessarily because it's slower, although it can be, but because of the DFA
 caching problem. The closure routine only considers the rule invocation stack
 created during prediction beginning in the decision rule. For example, if
 prediction occurs without invoking another rule's ATN, there are no context
 stacks in the configurations. When lack of context leads to a conflict, we
 don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 strategy (versus full LL(*)).</p>

 <p>
 When SLL yields a configuration set with conflict, we rewind the input and
 retry the ATN simulation, this time using full outer context without adding
 to the DFA. Configuration context stacks will be the full invocation stacks
 from the start rule. If we get a conflict using full context, then we can
 definitively say we have a true ambiguity for that input sequence. If we
 don't get a conflict, it implies that the decision is sensitive to the outer
 context. (It is not context-sensitive in the sense of context-sensitive
 grammars.)</p>

 <p>
 The next time we reach this DFA state with an SLL conflict, through DFA
 simulation, we will again retry the ATN simulation using full context mode.
 This is slow because we can't save the results and have to "interpret" the
 ATN each time we get that input.</p>

 <p>
 <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>

 <p>
 We could cache results from full context to predicted alternative easily and
 that saves a lot of time but doesn't work in presence of predicates. The set
 of visible predicates from the ATN start state changes depending on the
 context, because closure can fall off the end of a rule. I tried to cache
 tuples (stack context, semantic context, predicted alt) but it was slower
 than interpreting and much more complicated. Also required a huge amount of
 memory. The goal is not to create the world's fastest parser anyway. I'd like
 to keep this algorithm simple. By launching multiple threads, we can improve
 the speed of parsing across a large number of files.</p>

 <p>
 There is no strict ordering between the amount of input used by SLL vs LL,
 which makes it really hard to build a cache for full context. Let's say that
 we have input A B C that leads to an SLL conflict with full context X. That
 implies that using X we might only use A B but we could also use A B C D to
 resolve conflict. Input A B C D could predict alternative 1 in one position
 in the input and A B C E could predict alternative 2 in another position in
 input. The conflicting SLL configurations could still be non-unique in the
 full context prediction, which would lead us to requiring more input than the
 original A B C.        To make a       prediction cache work, we have to track the exact
 input  used during the previous prediction. That amounts to a cache that maps
 X to a specific DFA for that context.</p>

 <p>
 Something should be done for left-recursive expression predictions. They are
 likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 with full LL thing Sam does.</p>

 <p>
 <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>

 <p>
 We avoid doing full context retry when the outer context is empty, we did not
 dip into the outer context by falling off the end of the decision state rule,
 or when we force SLL mode.</p>

 <p>
 As an example of the not dip into outer context case, consider as super
 constructor calls versus function calls. One grammar might look like
 this:</p>

 <pre>
 ctorBody
   : '{' superCall? stat* '}'
   ;
 </pre>

 <p>
 Or, you might see something like</p>

 <pre>
 stat
   : superCall ';'
   | expression ';'
   | ...
   ;
 </pre>

 <p>
 In both cases I believe that no closure operations will dip into the outer
 context. In the first case ctorBody in the worst case will stop at the '}'.
 In the 2nd case it should stop at the ';'. Both cases should stay within the
 entry rule and not dip into the outer context.</p>

 <p>
 <strong>PREDICATES</strong></p>

 <p>
 Predicates are always evaluated if present in either SLL or LL both. SLL and
 LL simulation deals with predicates differently. SLL collects predicates as
 it performs closure operations like ANTLR v3 did. It delays predicate
 evaluation until it reaches and accept state. This allows us to cache the SLL
 ATN simulation whereas, if we had evaluated predicates on-the-fly during
 closure, the DFA state configuration sets would be different and we couldn't
 build up a suitable DFA.</p>

 <p>
 When building a DFA accept state during ATN simulation, we evaluate any
 predicates and return the sole semantically valid alternative. If there is
 more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 we throw an exception. Alternatives without predicates act like they have
 true predicates. The simple way to think about it is to strip away all
 alternatives with false predicates and choose the minimum alternative that
 remains.</p>

 <p>
 When we start in the DFA and reach an accept state that's predicated, we test
 those and return the minimum semantically viable alternative. If no
 alternatives are viable, we throw an exception.</p>

 <p>
 During full LL ATN simulation, closure always evaluates predicates and
 on-the-fly. This is crucial to reducing the configuration set size during
 closure. It hits a landmine when parsing with the Java grammar, for example,
 without this on-the-fly evaluation.</p>

 <p>
 <strong>SHARING DFA</strong></p>

 <p>
 All instances of the same parser share the same decision DFAs through a
 static field. Each instance gets its own ATN simulator but they share the
 same <a href="#decisionToDFA"><code>decisionToDFA</code></a> field. They also share a
 <a href="PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn"><code>PredictionContextCache</code></a> object that makes sure that all
 <a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn"><code>PredictionContext</code></a> objects are shared among the DFA states. This makes
 a big size difference.</p>

 <p>
 <strong>THREAD SAFETY</strong></p>

 <p>
 The <a href="ParserATNSimulator.html" title="class in org.antlr.v4.runtime.atn"><code>ParserATNSimulator</code></a> locks on the <a href="#decisionToDFA"><code>decisionToDFA</code></a> field when
 it adds a new DFA object to that array. <a href="#addDFAEdge(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAEdge(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState, int, org.antlr.v4.runtime.dfa.DFAState)</code></a>
 locks on the DFA for the current decision when setting the
 <a href="../dfa/DFAState.html#edges"><code>DFAState.edges</code></a> field. <a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAState(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState)</code></a> locks on
 the DFA for the current decision when looking up a DFA state to see if it
 already exists. We must make sure that all requests to add DFA states that
 are equivalent result in the same shared DFA object. This is because lots of
 threads will be trying to update the DFA at once. The
 <a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAState(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState)</code></a> method also locks inside the DFA lock
 but this time on the shared context cache when it rebuilds the
 configurations' <a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn"><code>PredictionContext</code></a> objects using cached
 subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 safe as long as we can guarantee that all threads referencing
 <code>s.edge[t]</code> get the same physical target <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa"><code>DFAState</code></a>, or
 <code>null</code>. Once into the DFA, the DFA simulation does not reference the
 <a href="../dfa/DFA.html#states"><code>DFA.states</code></a> map. It follows the <a href="../dfa/DFAState.html#edges"><code>DFAState.edges</code></a> field to new
 targets. The DFA simulator will either find <a href="../dfa/DFAState.html#edges"><code>DFAState.edges</code></a> to be
 <code>null</code>, to be non-<code>null</code> and <code>dfa.edges[t]</code> null, or
 <code>dfa.edges[t]</code> to be non-null. The
 <a href="#addDFAEdge(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAEdge(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState, int, org.antlr.v4.runtime.dfa.DFAState)</code></a> method could be racing to set the field
 but in either case the DFA simulator works; if <code>null</code>, and requests ATN
 simulation. It could also race trying to get <code>dfa.edges[t]</code>, but either
 way it will work because it's not doing a test and set operation.</p>

 <p>
 <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
 Parsing)</strong></p>

 <p>
 Sam pointed out that if SLL does not give a syntax error, then there is no
 point in doing full LL, which is slower. We only have to try LL if we get a
 syntax error. For maximum speed, Sam starts the parser set to pure SLL
 mode with the <a href="../BailErrorStrategy.html" title="class in org.antlr.v4.runtime"><code>BailErrorStrategy</code></a>:</p>

 <pre>
 parser.<a href="../Recognizer.html#getInterpreter()"><code>getInterpreter()</code></a>.<a href="#setPredictionMode(org.antlr.v4.runtime.atn.PredictionMode)"><code>setPredictionMode</code></a><code>(</code><a href="PredictionMode.html#SLL"><code>PredictionMode.SLL</code></a><code>)</code>;
 parser.<a href="../Parser.html#setErrorHandler(org.antlr.v4.runtime.ANTLRErrorStrategy)"><code>setErrorHandler</code></a>(new <a href="../BailErrorStrategy.html" title="class in org.antlr.v4.runtime"><code>BailErrorStrategy</code></a>());
 </pre>

 <p>
 If it does not get a syntax error, then we're done. If it does get a syntax
 error, we need to retry with the combined SLL/LL strategy.</p>

 <p>
 The reason this works is as follows. If there are no SLL conflicts, then the
 grammar is SLL (at least for that input set). If there is an SLL conflict,
 the full LL analysis must yield a set of viable alternatives which is a
 subset of the alternatives reported by SLL. If the LL set is a singleton,
 then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 is truly ambiguous on the current input. If the LL set is smaller, then the
 SLL conflict resolution might choose an alternative that the full LL would
 rule out as a possibility based upon better context information. If that's
 the case, then the SLL parse will definitely get an error because the full LL
 analysis says it's not viable. If SLL conflict resolution chooses an
 alternative within the LL set, them both SLL and LL would choose the same
 alternative because they both choose the minimum of multiple conflicting
 alternatives.</p>

 <p>
 Let's say we have a set of SLL conflicting alternatives <code>{1, 2, 3}</code> and
 a smaller LL set called <em>s</em>. If <em>s</em> is <code>{2, 3}</code>, then SLL
 parsing will get an error because SLL will pursue alternative 1. If
 <em>s</em> is <code>{1, 2}</code> or <code>{1, 3}</code> then both SLL and LL will
 choose the same alternative because alternative one is the minimum of either
 set. If <em>s</em> is <code>{2}</code> or <code>{3}</code> then SLL will get a syntax
 error. If <em>s</em> is <code>{1}</code> then SLL will succeed.</p>

 <p>
 Of course, if the input is invalid, then we will get an error for sure in
 both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 the input.</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_dfa">_dfa</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_input">_input</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_outerContext">_outerContext</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_startIndex">_startIndex</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#debug">debug</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#decisionToDFA">decisionToDFA</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dfa_debug">dfa_debug</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../misc/DoubleKeyMap.html" title="class in org.antlr.v4.runtime.misc">DoubleKeyMap</a>&lt;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>,&#8203;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>,&#8203;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeCache">mergeCache</a></span></code></th>
<td class="colLast">
<div class="block">Each prediction operation uses a cache for merge of prediction contexts.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parser">parser</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry_debug">retry_debug</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#trace_atn_sim">trace_atn_sim</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT">TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT</a></span></code></th>
<td class="colLast">
<div class="block">Just in case this optimization is bad, add an ENV variable to turn it off</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.org.antlr.v4.runtime.atn.ATNSimulator">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;org.antlr.v4.runtime.atn.<a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ATNSimulator</a></h3>
<code><a href="ATNSimulator.html#atn">atn</a>, <a href="ATNSimulator.html#ERROR">ERROR</a>, <a href="ATNSimulator.html#sharedContextCache">sharedContextCache</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.antlr.v4.runtime.atn.ATN,org.antlr.v4.runtime.dfa.DFA%5B%5D,org.antlr.v4.runtime.atn.PredictionContextCache)">ParserATNSimulator</a></span>&#8203;(<a href="ATN.html" title="class in org.antlr.v4.runtime.atn">ATN</a>&nbsp;atn,
                  <a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[]&nbsp;decisionToDFA,
                  <a href="PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn">PredictionContextCache</a>&nbsp;sharedContextCache)</code></th>
<td class="colLast">
<div class="block">Testing only!</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(org.antlr.v4.runtime.Parser,org.antlr.v4.runtime.atn.ATN,org.antlr.v4.runtime.dfa.DFA%5B%5D,org.antlr.v4.runtime.atn.PredictionContextCache)">ParserATNSimulator</a></span>&#8203;(<a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a>&nbsp;parser,
                  <a href="ATN.html" title="class in org.antlr.v4.runtime.atn">ATN</a>&nbsp;atn,
                  <a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[]&nbsp;decisionToDFA,
                  <a href="PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn">PredictionContextCache</a>&nbsp;sharedContextCache)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected <a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#actionTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ActionTransition)">actionTransition</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                <a href="ActionTransition.html" title="class in org.antlr.v4.runtime.atn">ActionTransition</a>&nbsp;t)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#adaptivePredict(org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">adaptivePredict</a></span>&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
               int&nbsp;decision,
               <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addDFAEdge(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,org.antlr.v4.runtime.dfa.DFAState)">addDFAEdge</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
          <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;from,
          int&nbsp;t,
          <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;to)</code></th>
<td class="colLast">
<div class="block">Add an edge to the DFA, if possible.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)">addDFAState</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
           <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D)</code></th>
<td class="colLast">
<div class="block">Add state <code>D</code> to the DFA if it is not already present, and return
 the actual instance stored in the DFA.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyPrecedenceFilter(org.antlr.v4.runtime.atn.ATNConfigSet)">applyPrecedenceFilter</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">
<div class="block">This method transforms the start state computed by
 <a href="#computeStartState(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext,boolean)"><code>computeStartState(org.antlr.v4.runtime.atn.ATNState, org.antlr.v4.runtime.RuleContext, boolean)</code></a> to the special start state used by a
 precedence DFA for a particular precedence value.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#canDropLoopEntryEdgeInLeftRecursiveRule(org.antlr.v4.runtime.atn.ATNConfig)">canDropLoopEntryEdgeInLeftRecursiveRule</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config)</code></th>
<td class="colLast">
<div class="block">Implements first-edge (loop entry) elimination as an optimization
  during closure operations.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDFA()">clearDFA</a></span>()</code></th>
<td class="colLast">
<div class="block">Clear the DFA cache used by the current instance.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closure(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,boolean)">closure</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
       <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
       <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
       boolean&nbsp;collectPredicates,
       boolean&nbsp;fullCtx,
       boolean&nbsp;treatEofAsEpsilon)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closure_(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,int,boolean)">closure_</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
        boolean&nbsp;collectPredicates,
        boolean&nbsp;fullCtx,
        int&nbsp;depth,
        boolean&nbsp;treatEofAsEpsilon)</code></th>
<td class="colLast">
<div class="block">Do the actual work of walking epsilon edges</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closureCheckingStopState(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,int,boolean)">closureCheckingStopState</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
                        boolean&nbsp;collectPredicates,
                        boolean&nbsp;fullCtx,
                        int&nbsp;depth,
                        boolean&nbsp;treatEofAsEpsilon)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeReachSet(org.antlr.v4.runtime.atn.ATNConfigSet,int,boolean)">computeReachSet</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;closure,
               int&nbsp;t,
               boolean&nbsp;fullCtx)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeStartState(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext,boolean)">computeStartState</a></span>&#8203;(<a href="ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a>&nbsp;p,
                 <a href="../RuleContext.html" title="class in org.antlr.v4.runtime">RuleContext</a>&nbsp;ctx,
                 boolean&nbsp;fullCtx)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeTargetState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int)">computeTargetState</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                  <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;previousD,
                  int&nbsp;t)</code></th>
<td class="colLast">
<div class="block">Compute a target state for an edge in the DFA, and attempt to add the
 computed state and corresponding edge to the DFA.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dumpDeadEndConfigs(org.antlr.v4.runtime.NoViableAltException)">dumpDeadEndConfigs</a></span>&#8203;(<a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime">NoViableAltException</a>&nbsp;nvae)</code></th>
<td class="colLast">
<div class="block">Used for debugging in adaptivePredict around execATN but I cut
  it out for clarity now that alg.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#evalSemanticContext(org.antlr.v4.runtime.atn.SemanticContext,org.antlr.v4.runtime.ParserRuleContext,int,boolean)">evalSemanticContext</a></span>&#8203;(<a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>&nbsp;pred,
                   <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;parserCallStack,
                   int&nbsp;alt,
                   boolean&nbsp;fullCtx)</code></th>
<td class="colLast">
<div class="block">Evaluate a semantic context within a specific parser context.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#evalSemanticContext(org.antlr.v4.runtime.dfa.DFAState.PredPrediction%5B%5D,org.antlr.v4.runtime.ParserRuleContext,boolean)">evalSemanticContext</a></span>&#8203;(<a href="../dfa/DFAState.PredPrediction.html" title="class in org.antlr.v4.runtime.dfa">DFAState.PredPrediction</a>[]&nbsp;predPredictions,
                   <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext,
                   boolean&nbsp;complete)</code></th>
<td class="colLast">
<div class="block">Look through a list of predicate/alt pairs, returning alts for the
  pairs that win.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execATN(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">execATN</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
       <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;s0,
       <a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
       int&nbsp;startIndex,
       <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</code></th>
<td class="colLast">
<div class="block">Performs ATN simulation to compute a predicted alternative based
  upon the remaining input, but also updates the DFA cache to avoid
  having to traverse the ATN again for the same input sequence.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execATNWithFullContext(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">execATNWithFullContext</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                      <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D,
                      <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;s0,
                      <a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
                      int&nbsp;startIndex,
                      <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAltThatFinishedDecisionEntryRule(org.antlr.v4.runtime.atn.ATNConfigSet)">getAltThatFinishedDecisionEntryRule</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>protected <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConflictingAlts(org.antlr.v4.runtime.atn.ATNConfigSet)">getConflictingAlts</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">
<div class="block">Gets a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink"><code>BitSet</code></a> containing the alternatives in <code>configs</code>
 which are part of one or more conflicting alternative subsets.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>protected <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConflictingAltsOrUniqueAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">getConflictingAltsOrUniqueAlt</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">
<div class="block">Sam pointed out a problem with the previous definition, v3, of
         ambiguous states.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>protected <a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEpsilonTarget(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.Transition,boolean,boolean,boolean,boolean)">getEpsilonTarget</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                <a href="Transition.html" title="class in org.antlr.v4.runtime.atn">Transition</a>&nbsp;t,
                boolean&nbsp;collectPredicates,
                boolean&nbsp;inContext,
                boolean&nbsp;fullCtx,
                boolean&nbsp;treatEofAsEpsilon)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>protected <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getExistingTargetState(org.antlr.v4.runtime.dfa.DFAState,int)">getExistingTargetState</a></span>&#8203;(<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;previousD,
                      int&nbsp;t)</code></th>
<td class="colLast">
<div class="block">Get an existing target state for an edge in the DFA.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLookaheadName(org.antlr.v4.runtime.TokenStream)">getLookaheadName</a></span>&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getParser()">getParser</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>protected <a href="../dfa/DFAState.PredPrediction.html" title="class in org.antlr.v4.runtime.dfa">DFAState.PredPrediction</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPredicatePredictions(java.util.BitSet,org.antlr.v4.runtime.atn.SemanticContext%5B%5D)">getPredicatePredictions</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
                       <a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>[]&nbsp;altToPred)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPredictionMode()">getPredictionMode</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>protected <a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPredsForAmbigAlts(java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet,int)">getPredsForAmbigAlts</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
                    <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                    int&nbsp;nalts)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>protected <a href="ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReachableTarget(org.antlr.v4.runtime.atn.Transition,int)">getReachableTarget</a></span>&#8203;(<a href="Transition.html" title="class in org.antlr.v4.runtime.atn">Transition</a>&nbsp;trans,
                  int&nbsp;ttype)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRuleName(int)">getRuleName</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSafeEnv(java.lang.String)">getSafeEnv</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;envName)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.ParserRuleContext)">getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                                       <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</code></th>
<td class="colLast">
<div class="block">This method is used to improve the localization of error messages by
 choosing an alternative rather than throwing a
 <a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime"><code>NoViableAltException</code></a> in particular prediction scenarios where the
 <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a> state was reached during ATN simulation.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTokenName(int)">getTokenName</a></span>&#8203;(int&nbsp;t)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>protected static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUniqueAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">getUniqueAlt</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>protected <a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime">NoViableAltException</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#noViableAlt(org.antlr.v4.runtime.TokenStream,org.antlr.v4.runtime.ParserRuleContext,org.antlr.v4.runtime.atn.ATNConfigSet,int)">noViableAlt</a></span>&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
           <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext,
           <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
           int&nbsp;startIndex)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#precedenceTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.PrecedencePredicateTransition,boolean,boolean,boolean)">precedenceTransition</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                    <a href="PrecedencePredicateTransition.html" title="class in org.antlr.v4.runtime.atn">PrecedencePredicateTransition</a>&nbsp;pt,
                    boolean&nbsp;collectPredicates,
                    boolean&nbsp;inContext,
                    boolean&nbsp;fullCtx)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#predicateDFAState(org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.atn.DecisionState)">predicateDFAState</a></span>&#8203;(<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;dfaState,
                 <a href="DecisionState.html" title="class in org.antlr.v4.runtime.atn">DecisionState</a>&nbsp;decisionState)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>protected <a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#predTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.PredicateTransition,boolean,boolean,boolean)">predTransition</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
              <a href="PredicateTransition.html" title="class in org.antlr.v4.runtime.atn">PredicateTransition</a>&nbsp;pt,
              boolean&nbsp;collectPredicates,
              boolean&nbsp;inContext,
              boolean&nbsp;fullCtx)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>protected <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeAllConfigsNotInRuleStopState(org.antlr.v4.runtime.atn.ATNConfigSet,boolean)">removeAllConfigsNotInRuleStopState</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                  boolean&nbsp;lookToEndOfRule)</code></th>
<td class="colLast">
<div class="block">Return a configuration set containing only the configurations from
 <code>configs</code> which are in a <a href="RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reportAmbiguity(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,int,boolean,java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet)">reportAmbiguity</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
               <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D,
               int&nbsp;startIndex,
               int&nbsp;stopIndex,
               boolean&nbsp;exact,
               <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
               <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</code></th>
<td class="colLast">
<div class="block">If context sensitive parsing, we know it's ambiguity not conflict</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reportAttemptingFullContext(org.antlr.v4.runtime.dfa.DFA,java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet,int,int)">reportAttemptingFullContext</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                           <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;conflictingAlts,
                           <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                           int&nbsp;startIndex,
                           int&nbsp;stopIndex)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reportContextSensitivity(org.antlr.v4.runtime.dfa.DFA,int,org.antlr.v4.runtime.atn.ATNConfigSet,int,int)">reportContextSensitivity</a></span>&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                        int&nbsp;prediction,
                        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                        int&nbsp;startIndex,
                        int&nbsp;stopIndex)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reset()">reset</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>protected <a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ruleTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.RuleTransition)">ruleTransition</a></span>&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
              <a href="RuleTransition.html" title="class in org.antlr.v4.runtime.atn">RuleTransition</a>&nbsp;t)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPredictionMode(org.antlr.v4.runtime.atn.PredictionMode)">setPredictionMode</a></span>&#8203;(<a href="PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;mode)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>protected <a href="../misc/Pair.html" title="class in org.antlr.v4.runtime.misc">Pair</a>&lt;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>,&#8203;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitAccordingToSemanticValidity(org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.ParserRuleContext)">splitAccordingToSemanticValidity</a></span>&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</code></th>
<td class="colLast">
<div class="block">Walk the list of configurations and split them according to
  those that have preds evaluating to true/false.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.antlr.v4.runtime.atn.ATNSimulator">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;org.antlr.v4.runtime.atn.<a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ATNSimulator</a></h3>
<code><a href="ATNSimulator.html#getCachedContext(org.antlr.v4.runtime.atn.PredictionContext)">getCachedContext</a>, <a href="ATNSimulator.html#getSharedContextCache()">getSharedContextCache</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true" title="class or interface in java.lang" class="externalLink">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang" class="externalLink">clone</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang" class="externalLink">equals</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang" class="externalLink">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang" class="externalLink">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang" class="externalLink">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang" class="externalLink">notify</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang" class="externalLink">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang" class="externalLink">toString</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang" class="externalLink">wait</a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html?is-external=true#wait(long,int)" title="class or interface in java.lang" class="externalLink">wait</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="debug">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>debug</h4>
<pre>public static&nbsp;boolean debug</pre>
</li>
</ul>
<a id="trace_atn_sim">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trace_atn_sim</h4>
<pre>public static&nbsp;boolean trace_atn_sim</pre>
</li>
</ul>
<a id="dfa_debug">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dfa_debug</h4>
<pre>public static&nbsp;boolean dfa_debug</pre>
</li>
</ul>
<a id="retry_debug">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry_debug</h4>
<pre>public static&nbsp;boolean retry_debug</pre>
</li>
</ul>
<a id="TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT</h4>
<pre>public static final&nbsp;boolean TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT</pre>
<div class="block">Just in case this optimization is bad, add an ENV variable to turn it off</div>
</li>
</ul>
<a id="parser">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parser</h4>
<pre>protected final&nbsp;<a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a> parser</pre>
</li>
</ul>
<a id="decisionToDFA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decisionToDFA</h4>
<pre>public final&nbsp;<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[] decisionToDFA</pre>
</li>
</ul>
<a id="mergeCache">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeCache</h4>
<pre>protected&nbsp;<a href="../misc/DoubleKeyMap.html" title="class in org.antlr.v4.runtime.misc">DoubleKeyMap</a>&lt;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>,&#8203;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>,&#8203;<a href="PredictionContext.html" title="class in org.antlr.v4.runtime.atn">PredictionContext</a>&gt; mergeCache</pre>
<div class="block">Each prediction operation uses a cache for merge of prediction contexts.
  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
  isn't synchronized but we're ok since two threads shouldn't reuse same
  parser/atnsim object because it can only handle one input at a time.
  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
  also be examined during cache lookup.</div>
</li>
</ul>
<a id="_input">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_input</h4>
<pre>protected&nbsp;<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a> _input</pre>
</li>
</ul>
<a id="_startIndex">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_startIndex</h4>
<pre>protected&nbsp;int _startIndex</pre>
</li>
</ul>
<a id="_outerContext">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_outerContext</h4>
<pre>protected&nbsp;<a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a> _outerContext</pre>
</li>
</ul>
<a id="_dfa">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_dfa</h4>
<pre>protected&nbsp;<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a> _dfa</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(org.antlr.v4.runtime.atn.ATN,org.antlr.v4.runtime.dfa.DFA[],org.antlr.v4.runtime.atn.PredictionContextCache)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ParserATNSimulator</h4>
<pre>public&nbsp;ParserATNSimulator&#8203;(<a href="ATN.html" title="class in org.antlr.v4.runtime.atn">ATN</a>&nbsp;atn,
                          <a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[]&nbsp;decisionToDFA,
                          <a href="PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn">PredictionContextCache</a>&nbsp;sharedContextCache)</pre>
<div class="block">Testing only!</div>
</li>
</ul>
<a id="&lt;init&gt;(org.antlr.v4.runtime.Parser,org.antlr.v4.runtime.atn.ATN,org.antlr.v4.runtime.dfa.DFA[],org.antlr.v4.runtime.atn.PredictionContextCache)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ParserATNSimulator</h4>
<pre>public&nbsp;ParserATNSimulator&#8203;(<a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a>&nbsp;parser,
                          <a href="ATN.html" title="class in org.antlr.v4.runtime.atn">ATN</a>&nbsp;atn,
                          <a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>[]&nbsp;decisionToDFA,
                          <a href="PredictionContextCache.html" title="class in org.antlr.v4.runtime.atn">PredictionContextCache</a>&nbsp;sharedContextCache)</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="reset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;reset()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ATNSimulator.html#reset()">reset</a></code>&nbsp;in class&nbsp;<code><a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ATNSimulator</a></code></dd>
</dl>
</li>
</ul>
<a id="clearDFA()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDFA</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearDFA()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="ATNSimulator.html#clearDFA()">ATNSimulator</a></code></span></div>
<div class="block">Clear the DFA cache used by the current instance. Since the DFA cache may
 be shared by multiple ATN simulators, this method may affect the
 performance (but not accuracy) of other parsers which are being used
 concurrently.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="ATNSimulator.html#clearDFA()">clearDFA</a></code>&nbsp;in class&nbsp;<code><a href="ATNSimulator.html" title="class in org.antlr.v4.runtime.atn">ATNSimulator</a></code></dd>
</dl>
</li>
</ul>
<a id="adaptivePredict(org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adaptivePredict</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;adaptivePredict&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
                           int&nbsp;decision,
                           <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</pre>
</li>
</ul>
<a id="execATN(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execATN</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;execATN&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                      <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;s0,
                      <a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
                      int&nbsp;startIndex,
                      <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</pre>
<div class="block">Performs ATN simulation to compute a predicted alternative based
  upon the remaining input, but also updates the DFA cache to avoid
  having to traverse the ATN again for the same input sequence.

         There are some key conditions we're looking for after computing a new
         set of ATN configs (proposed DFA state):
 if the set is empty, there is no viable alternative for current symbol
 does the state uniquely predict an alternative?
 does the state have a conflict that would prevent us from
                 putting it on the work list?

         We also have some key operations to do:
 add an edge from previous DFA state to potentially new DFA state, D,
                 upon current symbol but only if adding to work list, which means in all
                 cases except no viable alternative (and possibly non-greedy decisions?)
 collecting predicates and adding semantic context to DFA accept states
 adding rule context to context-sensitive DFA accept states
 consuming an input symbol
 reporting a conflict
 reporting an ambiguity
 reporting a context sensitivity
 reporting insufficient predicates

         cover these cases:
            dead end
            single alt
            single alt + preds
            conflict
            conflict + preds</div>
</li>
</ul>
<a id="getExistingTargetState(org.antlr.v4.runtime.dfa.DFAState,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExistingTargetState</h4>
<pre class="methodSignature">protected&nbsp;<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;getExistingTargetState&#8203;(<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;previousD,
                                          int&nbsp;t)</pre>
<div class="block">Get an existing target state for an edge in the DFA. If the target state
 for the edge has not yet been computed or is otherwise not available,
 this method returns <code>null</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>previousD</code> - The current DFA state</dd>
<dd><code>t</code> - The next input symbol</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The existing target DFA state for the given input symbol
 <code>t</code>, or <code>null</code> if the target state for this edge is not
 already cached</dd>
</dl>
</li>
</ul>
<a id="computeTargetState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeTargetState</h4>
<pre class="methodSignature">protected&nbsp;<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;computeTargetState&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                                      <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;previousD,
                                      int&nbsp;t)</pre>
<div class="block">Compute a target state for an edge in the DFA, and attempt to add the
 computed state and corresponding edge to the DFA.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dfa</code> - The DFA</dd>
<dd><code>previousD</code> - The current DFA state</dd>
<dd><code>t</code> - The next input symbol</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The computed target DFA state for the given input symbol
 <code>t</code>. If <code>t</code> does not lead to a valid DFA state, this method
 returns <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a>.</dd>
</dl>
</li>
</ul>
<a id="predicateDFAState(org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.atn.DecisionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predicateDFAState</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;predicateDFAState&#8203;(<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;dfaState,
                                 <a href="DecisionState.html" title="class in org.antlr.v4.runtime.atn">DecisionState</a>&nbsp;decisionState)</pre>
</li>
</ul>
<a id="execATNWithFullContext(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execATNWithFullContext</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;execATNWithFullContext&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                                     <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D,
                                     <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;s0,
                                     <a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
                                     int&nbsp;startIndex,
                                     <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</pre>
</li>
</ul>
<a id="computeReachSet(org.antlr.v4.runtime.atn.ATNConfigSet,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeReachSet</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;computeReachSet&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;closure,
                                       int&nbsp;t,
                                       boolean&nbsp;fullCtx)</pre>
</li>
</ul>
<a id="removeAllConfigsNotInRuleStopState(org.antlr.v4.runtime.atn.ATNConfigSet,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAllConfigsNotInRuleStopState</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;removeAllConfigsNotInRuleStopState&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                                          boolean&nbsp;lookToEndOfRule)</pre>
<div class="block">Return a configuration set containing only the configurations from
 <code>configs</code> which are in a <a href="RuleStopState.html" title="class in org.antlr.v4.runtime.atn"><code>RuleStopState</code></a>. If all
 configurations in <code>configs</code> are already in a rule stop state, this
 method simply returns <code>configs</code>.

 <p>When <code>lookToEndOfRule</code> is true, this method uses
 <a href="ATN.html#nextTokens(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext)"><code>ATN.nextTokens(org.antlr.v4.runtime.atn.ATNState, org.antlr.v4.runtime.RuleContext)</code></a> for each configuration in <code>configs</code> which is
 not already in a rule stop state to see if a rule stop state is reachable
 from the configuration via epsilon-only transitions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>configs</code> - the configuration set to update</dd>
<dd><code>lookToEndOfRule</code> - when true, this method checks for rule stop states
 reachable by epsilon-only transitions from each configuration in
 <code>configs</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>configs</code> if all configurations in <code>configs</code> are in a
 rule stop state, otherwise return a new configuration set containing only
 the configurations from <code>configs</code> which are in a rule stop state</dd>
</dl>
</li>
</ul>
<a id="computeStartState(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeStartState</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;computeStartState&#8203;(<a href="ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a>&nbsp;p,
                                         <a href="../RuleContext.html" title="class in org.antlr.v4.runtime">RuleContext</a>&nbsp;ctx,
                                         boolean&nbsp;fullCtx)</pre>
</li>
</ul>
<a id="applyPrecedenceFilter(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyPrecedenceFilter</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;applyPrecedenceFilter&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">This method transforms the start state computed by
 <a href="#computeStartState(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext,boolean)"><code>computeStartState(org.antlr.v4.runtime.atn.ATNState, org.antlr.v4.runtime.RuleContext, boolean)</code></a> to the special start state used by a
 precedence DFA for a particular precedence value. The transformation
 process applies the following changes to the start state's configuration
 set.

 <ol>
 <li>Evaluate the precedence predicates for each configuration using
 <a href="SemanticContext.html#evalPrecedence(org.antlr.v4.runtime.Recognizer,org.antlr.v4.runtime.RuleContext)"><code>SemanticContext.evalPrecedence(org.antlr.v4.runtime.Recognizer&lt;?, ?&gt;, org.antlr.v4.runtime.RuleContext)</code></a>.</li>
 <li>When <a href="ATNConfig.html#isPrecedenceFilterSuppressed()"><code>ATNConfig.isPrecedenceFilterSuppressed()</code></a> is <code>false</code>,
 remove all configurations which predict an alternative greater than 1,
 for which another configuration that predicts alternative 1 is in the
 same ATN state with the same prediction context. This transformation is
 valid for the following reasons:
 <ul>
 <li>The closure block cannot contain any epsilon transitions which bypass
 the body of the closure, so all states reachable via alternative 1 are
 part of the precedence alternatives of the transformed left-recursive
 rule.</li>
 <li>The "primary" portion of a left recursive rule cannot contain an
 epsilon transition, so the only way an alternative other than 1 can exist
 in a state that is also reachable via alternative 1 is by nesting calls
 to the left-recursive rule, with the outer calls not being at the
 preferred precedence level. The
 <a href="ATNConfig.html#isPrecedenceFilterSuppressed()"><code>ATNConfig.isPrecedenceFilterSuppressed()</code></a> property marks ATN
 configurations which do not meet this condition, and therefore are not
 eligible for elimination during the filtering process.</li>
 </ul>
 </li>
 </ol>

 <p>
 The prediction context must be considered by this filter to address
 situations like the following.
 </p>
 <code>
 <pre>
 grammar TA;
 prog: statement* EOF;
 statement: letterA | statement letterA 'b' ;
 letterA: 'a';
 </pre>
 </code>
 <p>
 If the above grammar, the ATN state immediately before the token
 reference <code>'a'</code> in <code>letterA</code> is reachable from the left edge
 of both the primary and closure blocks of the left-recursive rule
 <code>statement</code>. The prediction context associated with each of these
 configurations distinguishes between them, and prevents the alternative
 which stepped out to <code>prog</code> (and then back in to <code>statement</code>
 from being eliminated by the filter.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>configs</code> - The configuration set computed by
 <a href="#computeStartState(org.antlr.v4.runtime.atn.ATNState,org.antlr.v4.runtime.RuleContext,boolean)"><code>computeStartState(org.antlr.v4.runtime.atn.ATNState, org.antlr.v4.runtime.RuleContext, boolean)</code></a> as the start state for the DFA.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The transformed configuration set representing the start state
 for a precedence DFA at a particular precedence level (determined by
 calling <a href="../Parser.html#getPrecedence()"><code>Parser.getPrecedence()</code></a>).</dd>
</dl>
</li>
</ul>
<a id="getReachableTarget(org.antlr.v4.runtime.atn.Transition,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReachableTarget</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNState.html" title="class in org.antlr.v4.runtime.atn">ATNState</a>&nbsp;getReachableTarget&#8203;(<a href="Transition.html" title="class in org.antlr.v4.runtime.atn">Transition</a>&nbsp;trans,
                                      int&nbsp;ttype)</pre>
</li>
</ul>
<a id="getPredsForAmbigAlts(java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPredsForAmbigAlts</h4>
<pre class="methodSignature">protected&nbsp;<a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>[]&nbsp;getPredsForAmbigAlts&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
                                                 <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                                 int&nbsp;nalts)</pre>
</li>
</ul>
<a id="getPredicatePredictions(java.util.BitSet,org.antlr.v4.runtime.atn.SemanticContext[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPredicatePredictions</h4>
<pre class="methodSignature">protected&nbsp;<a href="../dfa/DFAState.PredPrediction.html" title="class in org.antlr.v4.runtime.dfa">DFAState.PredPrediction</a>[]&nbsp;getPredicatePredictions&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
                                                            <a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>[]&nbsp;altToPred)</pre>
</li>
</ul>
<a id="getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.ParserRuleContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                                                      <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</pre>
<div class="block">This method is used to improve the localization of error messages by
 choosing an alternative rather than throwing a
 <a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime"><code>NoViableAltException</code></a> in particular prediction scenarios where the
 <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a> state was reached during ATN simulation.

 <p>
 The default implementation of this method uses the following
 algorithm to identify an ATN configuration which successfully parsed the
 decision entry rule. Choosing such an alternative ensures that the
 <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime"><code>ParserRuleContext</code></a> returned by the calling rule will be complete
 and valid, and the syntax error will be reported later at a more
 localized location.</p>

 <ul>
 <li>If a syntactically valid path or paths reach the end of the decision rule and
 they are semantically valid if predicated, return the min associated alt.</li>
 <li>Else, if a semantically invalid but syntactically valid path exist
 or paths exist, return the minimum associated alt.
 </li>
 <li>Otherwise, return <a href="ATN.html#INVALID_ALT_NUMBER"><code>ATN.INVALID_ALT_NUMBER</code></a>.</li>
 </ul>

 <p>
 In some scenarios, the algorithm described above could predict an
 alternative which will result in a <a href="../FailedPredicateException.html" title="class in org.antlr.v4.runtime"><code>FailedPredicateException</code></a> in
 the parser. Specifically, this could occur if the <em>only</em> configuration
 capable of successfully parsing to the end of the decision rule is
 blocked by a semantic predicate. By choosing this alternative within
 <a href="#adaptivePredict(org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)"><code>adaptivePredict(org.antlr.v4.runtime.TokenStream, int, org.antlr.v4.runtime.ParserRuleContext)</code></a> instead of throwing a
 <a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime"><code>NoViableAltException</code></a>, the resulting
 <a href="../FailedPredicateException.html" title="class in org.antlr.v4.runtime"><code>FailedPredicateException</code></a> in the parser will identify the specific
 predicate which is preventing the parser from successfully parsing the
 decision rule, which helps developers identify and correct logic errors
 in semantic predicates.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>configs</code> - The ATN configurations which were valid immediately before
 the <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a> state was reached</dd>
<dd><code>outerContext</code> - The is the \gamma_0 initial parser context from the paper
 or the parser stack at the instant before prediction commences.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The value to return from <a href="#adaptivePredict(org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)"><code>adaptivePredict(org.antlr.v4.runtime.TokenStream, int, org.antlr.v4.runtime.ParserRuleContext)</code></a>, or
 <a href="ATN.html#INVALID_ALT_NUMBER"><code>ATN.INVALID_ALT_NUMBER</code></a> if a suitable alternative was not
 identified and <a href="#adaptivePredict(org.antlr.v4.runtime.TokenStream,int,org.antlr.v4.runtime.ParserRuleContext)"><code>adaptivePredict(org.antlr.v4.runtime.TokenStream, int, org.antlr.v4.runtime.ParserRuleContext)</code></a> should report an error instead.</dd>
</dl>
</li>
</ul>
<a id="getAltThatFinishedDecisionEntryRule(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAltThatFinishedDecisionEntryRule</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;getAltThatFinishedDecisionEntryRule&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
</li>
</ul>
<a id="splitAccordingToSemanticValidity(org.antlr.v4.runtime.atn.ATNConfigSet,org.antlr.v4.runtime.ParserRuleContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splitAccordingToSemanticValidity</h4>
<pre class="methodSignature">protected&nbsp;<a href="../misc/Pair.html" title="class in org.antlr.v4.runtime.misc">Pair</a>&lt;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>,&#8203;<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&gt;&nbsp;splitAccordingToSemanticValidity&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                                                                 <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext)</pre>
<div class="block">Walk the list of configurations and split them according to
  those that have preds evaluating to true/false.  If no pred, assume
  true pred and include in succeeded set.  Returns Pair of sets.

  Create a new set so as not to alter the incoming parameter.

  Assumption: the input stream has been restored to the starting point
  prediction, which is where predicates need to evaluate.</div>
</li>
</ul>
<a id="evalSemanticContext(org.antlr.v4.runtime.dfa.DFAState.PredPrediction[],org.antlr.v4.runtime.ParserRuleContext,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>evalSemanticContext</h4>
<pre class="methodSignature">protected&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;evalSemanticContext&#8203;(<a href="../dfa/DFAState.PredPrediction.html" title="class in org.antlr.v4.runtime.dfa">DFAState.PredPrediction</a>[]&nbsp;predPredictions,
                                     <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext,
                                     boolean&nbsp;complete)</pre>
<div class="block">Look through a list of predicate/alt pairs, returning alts for the
  pairs that win. A <code>NONE</code> predicate indicates an alt containing an
  unpredicated config which behaves as "always true." If !complete
  then we stop at the first predicate that evaluates to true. This
  includes pairs with null predicates.</div>
</li>
</ul>
<a id="evalSemanticContext(org.antlr.v4.runtime.atn.SemanticContext,org.antlr.v4.runtime.ParserRuleContext,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>evalSemanticContext</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;evalSemanticContext&#8203;(<a href="SemanticContext.html" title="class in org.antlr.v4.runtime.atn">SemanticContext</a>&nbsp;pred,
                                      <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;parserCallStack,
                                      int&nbsp;alt,
                                      boolean&nbsp;fullCtx)</pre>
<div class="block">Evaluate a semantic context within a specific parser context.

 <p>
 This method might not be called for every semantic context evaluated
 during the prediction process. In particular, we currently do not
 evaluate the following but it may change in the future:</p>

 <ul>
 <li>Precedence predicates (represented by
 <a href="SemanticContext.PrecedencePredicate.html" title="class in org.antlr.v4.runtime.atn"><code>SemanticContext.PrecedencePredicate</code></a>) are not currently evaluated
 through this method.</li>
 <li>Operator predicates (represented by <a href="SemanticContext.AND.html" title="class in org.antlr.v4.runtime.atn"><code>SemanticContext.AND</code></a> and
 <a href="SemanticContext.OR.html" title="class in org.antlr.v4.runtime.atn"><code>SemanticContext.OR</code></a>) are evaluated as a single semantic
 context, rather than evaluating the operands individually.
 Implementations which require evaluation results from individual
 predicates should override this method to explicitly handle evaluation of
 the operands within operator predicates.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pred</code> - The semantic context to evaluate</dd>
<dd><code>parserCallStack</code> - The parser context in which to evaluate the
 semantic context</dd>
<dd><code>alt</code> - The alternative which is guarded by <code>pred</code></dd>
<dd><code>fullCtx</code> - <code>true</code> if the evaluation is occurring during LL
 prediction; otherwise, <code>false</code> if the evaluation is occurring
 during SLL prediction</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.3</dd>
</dl>
</li>
</ul>
<a id="closure(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closure</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;closure&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                       <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                       <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
                       boolean&nbsp;collectPredicates,
                       boolean&nbsp;fullCtx,
                       boolean&nbsp;treatEofAsEpsilon)</pre>
</li>
</ul>
<a id="closureCheckingStopState(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closureCheckingStopState</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;closureCheckingStopState&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
                                        boolean&nbsp;collectPredicates,
                                        boolean&nbsp;fullCtx,
                                        int&nbsp;depth,
                                        boolean&nbsp;treatEofAsEpsilon)</pre>
</li>
</ul>
<a id="closure_(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ATNConfigSet,java.util.Set,boolean,boolean,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closure_</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;closure_&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html?is-external=true" title="class or interface in java.util" class="externalLink">Set</a>&lt;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&gt;&nbsp;closureBusy,
                        boolean&nbsp;collectPredicates,
                        boolean&nbsp;fullCtx,
                        int&nbsp;depth,
                        boolean&nbsp;treatEofAsEpsilon)</pre>
<div class="block">Do the actual work of walking epsilon edges</div>
</li>
</ul>
<a id="canDropLoopEntryEdgeInLeftRecursiveRule(org.antlr.v4.runtime.atn.ATNConfig)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>canDropLoopEntryEdgeInLeftRecursiveRule</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;canDropLoopEntryEdgeInLeftRecursiveRule&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config)</pre>
<div class="block">Implements first-edge (loop entry) elimination as an optimization
  during closure operations.  See antlr/antlr4#1398.

 The optimization is to avoid adding the loop entry config when
 the exit path can only lead back to the same
 StarLoopEntryState after popping context at the rule end state
 (traversing only epsilon edges, so we're still in closure, in
 this same rule).

 We need to detect any state that can reach loop entry on
 epsilon w/o exiting rule. We don't have to look at FOLLOW
 links, just ensure that all stack tops for config refer to key
 states in LR rule.

 To verify we are in the right situation we must first check
 closure is at a StarLoopEntryState generated during LR removal.
 Then we check that each stack top of context is a return state
 from one of these cases:

   1. 'not' expr, '(' type ')' expr. The return state points at loop entry state
   2. expr op expr. The return state is the block end of internal block of (...)*
   3. 'between' expr 'and' expr. The return state of 2nd expr reference.
      That state points at block end of internal block of (...)*.
   4. expr '?' expr ':' expr. The return state points at block end,
      which points at loop entry state.

 If any is true for each stack top, then closure does not add a
 config to the current config set for edge[0], the loop entry branch.

  Conditions fail if any context for the current config is:

   a. empty (we'd fall out of expr to do a global FOLLOW which could
      even be to some weird spot in expr) or,
   b. lies outside of expr or,
   c. lies within expr but at a state not the BlockEndState
   generated during LR removal

 Do we need to evaluate predicates ever in closure for this case?

 No. Predicates, including precedence predicates, are only
 evaluated when computing a DFA start state. I.e., only before
 the lookahead (but not parser) consumes a token.

 There are no epsilon edges allowed in LR rule alt blocks or in
 the "primary" part (ID here). If closure is in
 StarLoopEntryState any lookahead operation will have consumed a
 token as there are no epsilon-paths that lead to
 StarLoopEntryState. We do not have to evaluate predicates
 therefore if we are in the generated StarLoopEntryState of a LR
 rule. Note that when making a prediction starting at that
 decision point, decision d=2, compute-start-state performs
 closure starting at edges[0], edges[1] emanating from
 StarLoopEntryState. That means it is not performing closure on
 StarLoopEntryState during compute-start-state.

 How do we know this always gives same prediction answer?

 Without predicates, loop entry and exit paths are ambiguous
 upon remaining input +b (in, say, a+b). Either paths lead to
 valid parses. Closure can lead to consuming + immediately or by
 falling out of this call to expr back into expr and loop back
 again to StarLoopEntryState to match +b. In this special case,
 we choose the more efficient path, which is to take the bypass
 path.

 The lookahead language has not changed because closure chooses
 one path over the other. Both paths lead to consuming the same
 remaining input during a lookahead operation. If the next token
 is an operator, lookahead will enter the choice block with
 operators. If it is not, lookahead will exit expr. Same as if
 closure had chosen to enter the choice block immediately.

 Closure is examining one config (some loopentrystate, some alt,
 context) which means it is considering exactly one alt. Closure
 always copies the same alt to any derived configs.

 How do we know this optimization doesn't mess up precedence in
 our parse trees?

 Looking through expr from left edge of stat only has to confirm
 that an input, say, a+b+c; begins with any valid interpretation
 of an expression. The precedence actually doesn't matter when
 making a decision in stat seeing through expr. It is only when
 parsing rule expr that we must use the precedence to get the
 right interpretation and, hence, parse tree.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.6</dd>
</dl>
</li>
</ul>
<a id="getRuleName(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRuleName</h4>
<pre class="methodSignature">public&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;getRuleName&#8203;(int&nbsp;index)</pre>
</li>
</ul>
<a id="getEpsilonTarget(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.Transition,boolean,boolean,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEpsilonTarget</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;getEpsilonTarget&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                     <a href="Transition.html" title="class in org.antlr.v4.runtime.atn">Transition</a>&nbsp;t,
                                     boolean&nbsp;collectPredicates,
                                     boolean&nbsp;inContext,
                                     boolean&nbsp;fullCtx,
                                     boolean&nbsp;treatEofAsEpsilon)</pre>
</li>
</ul>
<a id="actionTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.ActionTransition)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>actionTransition</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;actionTransition&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                     <a href="ActionTransition.html" title="class in org.antlr.v4.runtime.atn">ActionTransition</a>&nbsp;t)</pre>
</li>
</ul>
<a id="precedenceTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.PrecedencePredicateTransition,boolean,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>precedenceTransition</h4>
<pre class="methodSignature">public&nbsp;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;precedenceTransition&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                      <a href="PrecedencePredicateTransition.html" title="class in org.antlr.v4.runtime.atn">PrecedencePredicateTransition</a>&nbsp;pt,
                                      boolean&nbsp;collectPredicates,
                                      boolean&nbsp;inContext,
                                      boolean&nbsp;fullCtx)</pre>
</li>
</ul>
<a id="predTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.PredicateTransition,boolean,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predTransition</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;predTransition&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                   <a href="PredicateTransition.html" title="class in org.antlr.v4.runtime.atn">PredicateTransition</a>&nbsp;pt,
                                   boolean&nbsp;collectPredicates,
                                   boolean&nbsp;inContext,
                                   boolean&nbsp;fullCtx)</pre>
</li>
</ul>
<a id="ruleTransition(org.antlr.v4.runtime.atn.ATNConfig,org.antlr.v4.runtime.atn.RuleTransition)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ruleTransition</h4>
<pre class="methodSignature">protected&nbsp;<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;ruleTransition&#8203;(<a href="ATNConfig.html" title="class in org.antlr.v4.runtime.atn">ATNConfig</a>&nbsp;config,
                                   <a href="RuleTransition.html" title="class in org.antlr.v4.runtime.atn">RuleTransition</a>&nbsp;t)</pre>
</li>
</ul>
<a id="getConflictingAlts(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConflictingAlts</h4>
<pre class="methodSignature">protected&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;getConflictingAlts&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Gets a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink"><code>BitSet</code></a> containing the alternatives in <code>configs</code>
 which are part of one or more conflicting alternative subsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>configs</code> - The <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn"><code>ATNConfigSet</code></a> to analyze.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The alternatives in <code>configs</code> which are part of one or more
 conflicting alternative subsets. If <code>configs</code> does not contain any
 conflicting subsets, this method returns an empty <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink"><code>BitSet</code></a>.</dd>
</dl>
</li>
</ul>
<a id="getConflictingAltsOrUniqueAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConflictingAltsOrUniqueAlt</h4>
<pre class="methodSignature">protected&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;getConflictingAltsOrUniqueAlt&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">Sam pointed out a problem with the previous definition, v3, of
         ambiguous states. If we have another state associated with conflicting
         alternatives, we should keep going. For example, the following grammar

         s : (ID | ID ID?) ';' ;

         When the ATN simulation reaches the state before ';', it has a DFA
         state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
         12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
         because alternative to has another way to continue, via [6|2|[]].
         The key is that we have a single state that has config's only associated
         with a single alternative, 2, and crucially the state transitions
         among the configurations are all non-epsilon transitions. That means
         we don't consider any conflicts that include alternative 2. So, we
         ignore the conflict between alts 1 and 2. We ignore a set of
         conflicting alts when there is an intersection with an alternative
         associated with a single alt state in the state&rarr;config-list map.

         It's also the case that we might have two conflicting configurations but
         also a 3rd nonconflicting configuration for a different alternative:
         [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:

         a : A | A | A B ;

         After matching input A, we reach the stop state for rule A, state 1.
         State 8 is the state right before B. Clearly alternatives 1 and 2
         conflict and no amount of further lookahead will separate the two.
         However, alternative 3 will be able to continue and so we do not
         stop working on this state. In the previous example, we're concerned
         with states associated with the conflicting alternatives. Here alt
         3 is not associated with the conflicting configs, but since we can continue
         looking for input reasonably, I don't declare the state done. We
         ignore a set of conflicting alts when we have an alternative
         that we still need to pursue.</div>
</li>
</ul>
<a id="getTokenName(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTokenName</h4>
<pre class="methodSignature">public&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;getTokenName&#8203;(int&nbsp;t)</pre>
</li>
</ul>
<a id="getLookaheadName(org.antlr.v4.runtime.TokenStream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLookaheadName</h4>
<pre class="methodSignature">public&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;getLookaheadName&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input)</pre>
</li>
</ul>
<a id="dumpDeadEndConfigs(org.antlr.v4.runtime.NoViableAltException)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dumpDeadEndConfigs</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;dumpDeadEndConfigs&#8203;(<a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime">NoViableAltException</a>&nbsp;nvae)</pre>
<div class="block">Used for debugging in adaptivePredict around execATN but I cut
  it out for clarity now that alg. works well. We can leave this
  "dead" code for a bit.</div>
</li>
</ul>
<a id="noViableAlt(org.antlr.v4.runtime.TokenStream,org.antlr.v4.runtime.ParserRuleContext,org.antlr.v4.runtime.atn.ATNConfigSet,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noViableAlt</h4>
<pre class="methodSignature">protected&nbsp;<a href="../NoViableAltException.html" title="class in org.antlr.v4.runtime">NoViableAltException</a>&nbsp;noViableAlt&#8203;(<a href="../TokenStream.html" title="interface in org.antlr.v4.runtime">TokenStream</a>&nbsp;input,
                                           <a href="../ParserRuleContext.html" title="class in org.antlr.v4.runtime">ParserRuleContext</a>&nbsp;outerContext,
                                           <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                           int&nbsp;startIndex)</pre>
</li>
</ul>
<a id="getUniqueAlt(org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUniqueAlt</h4>
<pre class="methodSignature">protected static&nbsp;int&nbsp;getUniqueAlt&#8203;(<a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
</li>
</ul>
<a id="addDFAEdge(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,org.antlr.v4.runtime.dfa.DFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addDFAEdge</h4>
<pre class="methodSignature">protected&nbsp;<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;addDFAEdge&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                              <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;from,
                              int&nbsp;t,
                              <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;to)</pre>
<div class="block">Add an edge to the DFA, if possible. This method calls
 <a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAState(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState)</code></a> to ensure the <code>to</code> state is present in the
 DFA. If <code>from</code> is <code>null</code>, or if <code>t</code> is outside the
 range of edges that can be represented in the DFA tables, this method
 returns without adding the edge to the DFA.

 <p>If <code>to</code> is <code>null</code>, this method returns <code>null</code>.
 Otherwise, this method returns the <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa"><code>DFAState</code></a> returned by calling
 <a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAState(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState)</code></a> for the <code>to</code> state.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dfa</code> - The DFA</dd>
<dd><code>from</code> - The source state for the edge</dd>
<dd><code>t</code> - The input symbol</dd>
<dd><code>to</code> - The target state for the edge</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>If <code>to</code> is <code>null</code>, this method returns <code>null</code>;
 otherwise this method returns the result of calling <a href="#addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)"><code>addDFAState(org.antlr.v4.runtime.dfa.DFA, org.antlr.v4.runtime.dfa.DFAState)</code></a>
 on <code>to</code></dd>
</dl>
</li>
</ul>
<a id="addDFAState(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addDFAState</h4>
<pre class="methodSignature">protected&nbsp;<a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;addDFAState&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                               <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D)</pre>
<div class="block">Add state <code>D</code> to the DFA if it is not already present, and return
 the actual instance stored in the DFA. If a state equivalent to <code>D</code>
 is already in the DFA, the existing state is returned. Otherwise this
 method returns <code>D</code> after adding it to the DFA.

 <p>If <code>D</code> is <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a>, this method returns <a href="ATNSimulator.html#ERROR"><code>ATNSimulator.ERROR</code></a> and
 does not change the DFA.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dfa</code> - The dfa</dd>
<dd><code>D</code> - The DFA state to add</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The state stored in the DFA. This will be either the existing
 state if <code>D</code> is already in the DFA, or <code>D</code> itself if the
 state was not already present.</dd>
</dl>
</li>
</ul>
<a id="reportAttemptingFullContext(org.antlr.v4.runtime.dfa.DFA,java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reportAttemptingFullContext</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;reportAttemptingFullContext&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                                           <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;conflictingAlts,
                                           <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                           int&nbsp;startIndex,
                                           int&nbsp;stopIndex)</pre>
</li>
</ul>
<a id="reportContextSensitivity(org.antlr.v4.runtime.dfa.DFA,int,org.antlr.v4.runtime.atn.ATNConfigSet,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reportContextSensitivity</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;reportContextSensitivity&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                                        int&nbsp;prediction,
                                        <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs,
                                        int&nbsp;startIndex,
                                        int&nbsp;stopIndex)</pre>
</li>
</ul>
<a id="reportAmbiguity(org.antlr.v4.runtime.dfa.DFA,org.antlr.v4.runtime.dfa.DFAState,int,int,boolean,java.util.BitSet,org.antlr.v4.runtime.atn.ATNConfigSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reportAmbiguity</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;reportAmbiguity&#8203;(<a href="../dfa/DFA.html" title="class in org.antlr.v4.runtime.dfa">DFA</a>&nbsp;dfa,
                               <a href="../dfa/DFAState.html" title="class in org.antlr.v4.runtime.dfa">DFAState</a>&nbsp;D,
                               int&nbsp;startIndex,
                               int&nbsp;stopIndex,
                               boolean&nbsp;exact,
                               <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html?is-external=true" title="class or interface in java.util" class="externalLink">BitSet</a>&nbsp;ambigAlts,
                               <a href="ATNConfigSet.html" title="class in org.antlr.v4.runtime.atn">ATNConfigSet</a>&nbsp;configs)</pre>
<div class="block">If context sensitive parsing, we know it's ambiguity not conflict</div>
</li>
</ul>
<a id="setPredictionMode(org.antlr.v4.runtime.atn.PredictionMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPredictionMode</h4>
<pre class="methodSignature">public final&nbsp;void&nbsp;setPredictionMode&#8203;(<a href="PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;mode)</pre>
</li>
</ul>
<a id="getPredictionMode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPredictionMode</h4>
<pre class="methodSignature">public final&nbsp;<a href="PredictionMode.html" title="enum in org.antlr.v4.runtime.atn">PredictionMode</a>&nbsp;getPredictionMode()</pre>
</li>
</ul>
<a id="getParser()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParser</h4>
<pre class="methodSignature">public&nbsp;<a href="../Parser.html" title="class in org.antlr.v4.runtime">Parser</a>&nbsp;getParser()</pre>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.3</dd>
</dl>
</li>
</ul>
<a id="getSafeEnv(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getSafeEnv</h4>
<pre class="methodSignature">public static&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;getSafeEnv&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;envName)</pre>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/ParserATNSimulator.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 1992&#x2013;2023 <a href="https://www.antlr.org/">ANTLR</a>. All rights reserved.</small></p>
</footer>
</body>
</html>
